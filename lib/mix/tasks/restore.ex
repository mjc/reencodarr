defmodule Mix.Tasks.Restore do
  use Mix.Task

  @shortdoc "Restore the database from CSV dumps"

  @moduledoc """
  Restores all schemas from CSV files generated by the dump task.

      mix restore
  """

  alias Reencodarr.Repo

  def run(_args) do
    Mix.Task.run("app.start")

    {:ok, modules} = :application.get_key(:reencodarr, :modules)

    schemas =
      modules
      |> Enum.filter(&({:__schema__, 1} in &1.__info__(:functions)))

    Enum.each(schemas, &restore_schema/1)
  end

  # Restores a single schema from its CSV file
  defp restore_schema(schema) do
    file_name = "#{Atom.to_string(schema)}.csv"

    if File.exists?(file_name) do
      IO.puts("Restoring #{file_name} ...")

      [header | rows] =
        File.stream!(file_name, [], :line)
        |> Enum.map(&String.trim_trailing(&1, "\n"))

      fields = String.split(header, ",") |> Enum.map(&String.to_atom/1)
      Enum.each(rows, &process_csv_row(schema, &1, fields))
    end
  end

  # Processes a single CSV row: parses, validates, and inserts
  defp process_csv_row(schema, row, fields) do
    values = parse_csv_row(row)
    valid? = is_list(values) and length(values) == length(fields)

    if valid? do
      attrs =
        fields
        |> Enum.zip(values)
        |> Enum.into(%{}, fn {field, value} ->
          {field, parse_field(schema, field, value)}
        end)

      struct(schema, attrs)
      |> Repo.insert!()
    end
  end

  # Parses a CSV row into a list of values, handling quoted fields and escaped quotes
  defp parse_csv_row(row) do
    NimbleCSV.RFC4180.parse_string(row) |> List.first()
  end

  # Parse a field value based on schema type, return nil for empty string
  defp parse_field(_schema, _field, ""), do: nil

  defp parse_field(schema, field, value) do
    type = schema.__schema__(:type, field)
    parse_value_by_type(type, value)
  end

  # Parse value according to its expected type
  defp parse_value_by_type(:map, value), do: parse_json(value)
  defp parse_value_by_type(:array, value), do: parse_json(value)
  defp parse_value_by_type(:integer, value), do: parse_integer(value)
  defp parse_value_by_type(:float, value), do: parse_float(value)
  defp parse_value_by_type(:boolean, value), do: value in ["true", "1"]
  defp parse_value_by_type(:naive_datetime, value), do: parse_naive_datetime(value)
  defp parse_value_by_type(:utc_datetime, value), do: parse_utc_datetime(value)
  defp parse_value_by_type(_, value), do: value

  # Helper functions for specific type parsing
  defp parse_json(value) do
    case Jason.decode(value) do
      {:ok, result} -> result
      _ -> value
    end
  end

  defp parse_integer(value) do
    case Integer.parse(value) do
      {int_value, ""} -> int_value
      _ -> value
    end
  end

  defp parse_float(value) do
    case Float.parse(value) do
      {float_value, ""} -> float_value
      _ -> value
    end
  end

  defp parse_naive_datetime(value) do
    case NaiveDateTime.from_iso8601(value) do
      {:ok, result} -> result
      _ -> value
    end
  end

  defp parse_utc_datetime(value) do
    case DateTime.from_iso8601(value) do
      {:ok, result, _} -> result
      _ -> value
    end
  end
end
